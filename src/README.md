# 面试重点

## 使用技术

SpringBoot+nginx+MySql+Lombok+MyBatis-Plus+Hutool+Redis

使用 Redis 解决了在集群模式下的 Session共享问题,使用拦截器实现用户的登录校验和权限刷新

基于Cache Aside模式解决数据库与缓存的一致性问题

使用 Redis 对高频访问的信息进行缓存，降低了数据库查询的压力,解决了缓存穿透、雪崩、击穿问题使用 Redis + Lua脚

本实现对用户秒杀资格的预检，同时用乐观锁解决秒杀产生的超卖问题

使用Redis分布式锁解决了在集群模式下一人一单的线程安全问题

基于stream结构作为消息队列,实现异步秒杀下单

使用Redis的 ZSet 数据结构实现了点赞排行榜功能,使用Set 集合实现关注、共同关注功能

## 项目难点/亮点

### 使用Redis解决了在集群模式下的Session共享问题，使用拦截器实现了用户的登录校验和权限刷新

❓**为什么用Redis替代Session？**  

✅使用Session时，根据客户端发送的session-id获取Session，再从Session获取数据，由于Session共享问题：多台Tomct并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。  

解决方法：用Redis代替Session存储User信息，注册用户时，使用UUID生成随机的Token作为Key值存放用户到Redis中。

❓**还有其他解决方法吗？**  
 
✅基于 Cookie 的 Token 机制，不再使用服务器端保存 Session，而是通过客户端保存 Token（如 JWT）。Token 包含用户的认证信息（如用户 ID、权限等），并通过签名验证其完整性和真实性。每次请求，客户端将 Token 放在 Cookie 或 HTTP 头中发送到服务

❓**登录流程**  

![image](https://github.com/user-attachments/assets/d869adcc-37fe-433c-b206-f90290f6eb36)


❓**怎么使用拦截器实现这些功能？**  

![image](https://github.com/user-attachments/assets/759a3edb-0305-4c49-90f2-d986ed0f5040)

系统中设置了两层拦截器：

第一层拦截器是做全局处理，例如获取Token，查询Redis中的用户信息，刷新Token有效期等通用操作。

第二层拦截器专注于验证用户登录的逻辑，如果路径需要登录，但用户未登录，则直接拦截请求。

使用拦截器是因为，多个线程都需要获取用户，在想要方法之前统一做些操作，就需要用拦截器，还可以拦截没用登录的用户，但只有一层拦截器不是拦截所有请求，所有有些请求不会刷新Token时间，我们就需要再加一层拦截器，拦截所有请求，做到一直刷新。

好处：

职责分离：这种分层设计让每个拦截器的职责更加单一，代码更加清晰、易于维护

提升性能：如果直接在第一层拦截器处理登录验证，可能会对每个请求都进行不必要的检查。而第二层拦截器仅在“需要登录的路径”中生效，可以避免不必要的性能开销。

灵活性：这种机制方便扩展，不需要修改第一层的全局逻辑。

复用 ThreadLocal 数据：第一层拦截器已经将用户信息保存到 ThreadLocal 中，第二层拦截器可以直接使用这些数据，而不需要重复查询 Redis 或其他数据源。

### 基于Cache Aside模式解决数据库与缓存的一致性问题

❓**怎么保证缓存更新策略的高一致性需求？**

✅ 使用redission实现的读写锁，读时使用共享锁，保证读读不互斥、读写互斥、写写互斥。写时使用排他锁，保证读写互斥、读读互斥。保证写数据时不会脏数据。

### 使用 Redis 对高频访问的信息进行缓存，降低了数据库查询的压力,解决了缓存穿透、雪崩、击穿问题

❓**什么是缓存穿透，怎么解决？**

✅ 缓存穿透是用户请求数据在缓存中不存在或者用户恶意使用不存在的数据向服务器发起请求，大量并发访问数据库不存在的数据时，这个现象叫做缓存穿透。 缓存穿透可能导致数据库压力过大，最终导致数据库宕机等情况。  

解决方式：  

1️⃣ 增加对请求的校验机制，例如校验请求参数类型。

2️⃣ 使用布隆过滤器，为了避免缓存穿透，将要查询的数据提前存入布隆过滤器。新增数据时也将新增数据存入过滤器。如果在查询时使用过滤器中不存在的数据时，可以直接返回。

3️⃣ 使用空值或特殊值缓存，当请求数据在缓存中不存在时，仍然会查询数据库，如果数据库也不存在时，将会写入一个空值或者特殊值到缓存中(设置过期时间)。

❓**什么是缓存雪崩，怎么解决？**

✅ 缓存雪崩是缓存中大量key失效，如果高并发来临时导致大量请求直接到数据库，导致数据库宕机等情况。

解决方式：  

1️⃣ 使用同步锁控制查询数据库的线程，一次只允许一个线程查询，这种方法效率较低。

2️⃣ 对同一类型的key设置不同的过期时间。

3️⃣ 使用缓存预热，提前将数据存入缓存，通常使用专门的后台程序将数据库数据存入缓存。

❓**什么是缓存击穿，怎么解决？**

✅ 缓存击穿是热点key问题，大量并发请求到一个热点key，当热点key失效时，大量请求到数据库，导致数据库资源耗尽，从而数据库宕机的情况。

解决方式：  

1️⃣ 使用互斥锁解决。优点是内存占用小，高一致性，实现简单。缺点是性能较低，可能会出现死锁。通过Redis中setnx指令实现互斥锁，只有当值不存在时才可以写入成功。线程获取锁后，需要查询缓存才能保证缓存不被击穿。

2️⃣ 缓存数据使用逻辑过期。优点是性能高。缺点是内存占用较大，会出现脏读。使用逻辑过期需要将数据预热，提前将数据写入缓存。当缓存真的过期时，开启一个子线程重建缓存，主线程的请求依旧返回旧数据，不会被阻塞，但是会出现脏读。

### 使用 Redis + Lua脚本实现对用户秒杀资格的预检，同时用乐观锁解决秒杀产生的超卖问题

❓**什么是超卖问题，怎么解决？**

✅ 超卖问题是当有多个线程对数据库库存进行查询后，但是为进行更新时，导致错误扣减库存的情况。

解决方式：  

1️⃣ 使用悲观锁，让线程串行执行。优点：简单安全。缺点：性能较低。

2️⃣ 使用乐观锁，使用CAS自旋思想，当更新库存时，与之前查询的结果进行比较，如果不相同则自旋。

### 使用Redis分布式锁解决了在集群模式下一人一单的线程安全问题

❓**Redis分布式锁实现思路？**

✅ 使用Redission分布式锁，实现可重入，可重试。可重入是同一线程可以再次获取锁，避免死锁。可重试是Redission手动加锁，控制锁的失效时间和等待时间，当获取锁线程未完成业务时，Redission引入了Watch Dog机制。每隔一段时间检查当前业务是否还是持有锁，如果继续持有就增加锁的时间，当业务完成后释放锁。

![image](https://github.com/user-attachments/assets/b2d0f495-aa04-4d7a-8252-5e8d713134af)


来自 [🎁CSDN-黑马点评完整代码+简历编写+面试重点](https://blog.csdn.net/KNeeg_/article/details/146123658)
